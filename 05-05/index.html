<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../styles.css" />

    <title>05-05</title>
  </head>
  <body>
    <section class="exercise">
      <h3>1. Переведите текст вида border-left-width в borderLeftWidth</h3>
      <p>
        Напишите функцию camelize(str), которая преобразует строки вида
        «my-short-string» в «myShortString».
      </p>
      <p>
        То есть дефисы удаляются, а все слова после них получают заглавную
        букву.
      </p>
      <p>Примеры:</p>
      <pre class="code">
        camelize("background-color") == 'backgroundColor';
        camelize("list-style-image") == 'listStyleImage';
        camelize("-webkit-transition") == 'WebkitTransition';</pre
      >
      <p>
        P.S. Подсказка: используйте split, чтобы разбить строку на массив
        символов, потом переделайте всё как нужно и методом join соедините
        обратно.
      </p>
    </section>
    <section class="exercise">
      <h3>2. Фильтрация по диапазону</h3>
      <p>
        Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
        ищет элементы со значениями больше или равными a и меньше или равными b
        и возвращает результат в виде массива.
      </p>
      <p>Функция должна возвращать новый массив и не изменять исходный.</p>
      <p>Например:</p>
      <pre class="code">
        let arr = [5, 3, 8, 1];

        let filtered = filterRange(arr, 1, 4);
        
        alert( filtered ); // 3,1 (совпадающие значения)
        
        alert( arr ); // 5,3,8,1 (без изменений)</pre
      >
    </section>
    <section class="exercise">
      <h3>3. Фильтрация по диапазону "на месте"</h3>
      <p>
        Напишите функцию filterRangeInPlace(arr, a, b), которая принимает массив
        arr и удаляет из него все значения кроме тех, которые находятся между a
        и b. То есть, проверка имеет вид a ≤ arr[i] ≤ b.
      </p>
      <p>Функция должна изменять принимаемый массив и ничего не возвращать.</p>
      <p>Например:</p>
      <pre class="code">
        let arr = [5, 3, 8, 1];

        filterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4
        
        alert( arr ); // [3, 1]</pre
      >
    </section>
    <section class="exercise">
      <h3>4. Сортировать в порядке по убыванию</h3>
      <pre class="code">
        let arr = [5, 2, 1, -10, 8];

        // ... ваш код для сортировки по убыванию
        
        alert( arr ); // 8, 5, 2, 1, -10</pre
      >
    </section>
    <section class="exercise">
      <h3>5. Скопировать и отсортировать массив</h3>
      <p>
        У нас есть массив строк arr. Нужно получить отсортированную копию, но
        оставить arr неизменённым.
      </p>
      <p>
        Создайте функцию copySorted(arr), которая будет возвращать такую копию.
      </p>
      <pre class="code">
        let arr = [5, 2, 1, -10, 8];

        // ... ваш код для сортировки по убыванию
        
        alert( arr ); // 8, 5, 2, 1, -10</pre
      >
    </section>
    <section class="exercise">
      <h3>6. Создать расширяемый калькулятор</h3>
      <p>
        Создайте функцию конструктор Calculator, которая создаёт «расширяемые»
        объекты калькулятора.
      </p>
      <p>Задание состоит из двух частей.</p>
      <ol>
        <li>
          <p>
            Во-первых, реализуйте метод calculate(str), который принимает строку
            типа "1 + 2" в формате «ЧИСЛО оператор ЧИСЛО» (разделено пробелами)
            и возвращает результат. Метод должен понимать плюс + и минус -.
          </p>
          <p>Пример использования:</p>
          <pre class="code">
          let calc = new Calculator;

          alert( calc.calculate("3 + 7") ); // 10</pre
          >
        </li>
        <li>
          <p>
            Затем добавьте метод addMethod(name, func), который добавляет в
            калькулятор новые операции. Он принимает оператор name и функцию с
            двумя аргументами func(a,b), которая описывает его.
          </p>
          <p>
            Например, давайте добавим умножение *, деление / и возведение в
            степень **:
          </p>
          <pre class="code">
            let powerCalc = new Calculator;
            powerCalc.addMethod("*", (a, b) => a * b);
            powerCalc.addMethod("/", (a, b) => a / b);
            powerCalc.addMethod("**", (a, b) => a ** b);
            
            let result = powerCalc.calculate("2 ** 3");
            alert( result ); // 8</pre
          >
        </li>
      </ol>
      <ul>
        <li>Для этой задачи не нужны скобки или сложные выражения.</li>
        <li>Числа и оператор разделены ровно одним пробелом.</li>
        <li>Не лишним будет добавить обработку ошибок.</li>
      </ul>
    </section>
    <section class="exercise">
      <h3>7. Трансформировать в массив имён</h3>
      <p>
        У вас есть массив объектов user, и в каждом из них есть user.name.
        Напишите код, который преобразует их в массив имён.
      </p>
      <p>Например:</p>
      <pre class="code">
        let vasya = { name: "Вася", age: 25 };
        let petya = { name: "Петя", age: 30 };
        let masha = { name: "Маша", age: 28 };
        
        let users = [ vasya, petya, masha ];
        
        let names = /* ... ваш код */
        
        alert( names ); // Вася, Петя, Маша</pre
      >
    </section>
    <section class="exercise">
      <h3>8. Трансформировать в массив имён</h3>
      <p>
        У вас есть массив объектов user, и у каждого из объектов есть name,
        surname и id.
      </p>
      <p>
        Напишите код, который создаст ещё один массив объектов с параметрами id
        и fullName, где fullName – состоит из name и surname.
      </p>
      <p>Например:</p>
      <pre class="code">
        let vasya = { name: "Вася", surname: "Пупкин", id: 1 };
        let petya = { name: "Петя", surname: "Иванов", id: 2 };
        let masha = { name: "Маша", surname: "Петрова", id: 3 };
        
        let users = [ vasya, petya, masha ];
        
        let usersMapped = /* ... ваш код ... */
        
        /*
        usersMapped = [
          { fullName: "Вася Пупкин", id: 1 },
          { fullName: "Петя Иванов", id: 2 },
          { fullName: "Маша Петрова", id: 3 }
        ]
        */
        
        alert( usersMapped[0].id ) // 1
        alert( usersMapped[0].fullName ) // Вася Пупкин</pre
      >
      <p>
        Итак, на самом деле вам нужно трансформировать один массив объектов в
        другой. Попробуйте использовать =>. Это небольшая уловка.
      </p>
    </section>
    <section class="exercise">
      <h3>9. Трансформировать в массив имён</h3>
      <p>
        Напишите функцию sortByAge(users), которая принимает массив объектов со
        свойством age и сортирует их по нему.
      </p>
      <p>Например:</p>
      <pre class="code">
        let vasya = { name: "Вася", age: 25 };
        let petya = { name: "Петя", age: 30 };
        let masha = { name: "Маша", age: 28 };
        
        let arr = [ vasya, petya, masha ];
        
        sortByAge(arr);
        
        // теперь: [vasya, masha, petya]
        alert(arr[0].name); // Вася
        alert(arr[1].name); // Маша
        alert(arr[2].name); // Петя</pre
      >
    </section>
    <section class="exercise">
      <h3>10. Перемешайте массив</h3>
      <p>
        Напишите функцию shuffle(array), которая перемешивает (переупорядочивает
        случайным образом) элементы массива.
      </p>
      <p>
        Многократные прогоны через shuffle могут привести к разным
        последовательностям элементов. Например:
      </p>
      <pre class="code">
        let arr = [1, 2, 3];

        shuffle(arr);
        // arr = [3, 2, 1]
        
        shuffle(arr);
        // arr = [2, 1, 3]
        
        shuffle(arr);
        // arr = [3, 1, 2]
        // ...</pre
      >
      <p>
        Все последовательности элементов должны иметь одинаковую вероятность.
        Например, [1,2,3] может быть переупорядочено как [1,2,3] или [1,3,2],
        или [3,1,2] и т.д., с равной вероятностью каждого случая.
      </p>
    </section>
    <section class="exercise">
      <h3>11. Получить средний возраст</h3>
      <p>
        Напишите функцию getAverageAge(users), которая принимает массив объектов
        со свойством age и возвращает средний возраст.
      </p>
      <p>
        Формула вычисления среднего арифметического значения: (age1 + age2 + ...
        + ageN) / N.
      </p>
      <p>Например:</p>
      <pre class="code">
        let vasya = { name: "Вася", age: 25 };
        let petya = { name: "Петя", age: 30 };
        let masha = { name: "Маша", age: 29 };
        
        let arr = [ vasya, petya, masha ];
        
        alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28</pre
      >
    </section>
    <section class="exercise">
      <h3>12. Оставить уникальные элементы массива</h3>
      <p>Пусть arr – массив строк.</p>
      <p>
        Напишите функцию unique(arr), которая возвращает массив, содержащий
        только уникальные элементы arr.
      </p>
      <p>Например:</p>
      <pre class="code">
        function unique(arr) {
          /* ваш код */
        }
        
        let strings = ["кришна", "кришна", "харе", "харе",
          "харе", "харе", "кришна", "кришна", ":-O"
        ];
        
        alert( unique(strings) ); // кришна, харе, :-O</pre
      >
    </section>
    <section class="exercise">
      <h3>13. Создайте объект с ключами из массива</h3>
      <p>
        Допустим, мы получили массив пользователей в виде {id:..., name:...,
        age:... }.
      </p>
      <p>
        Создайте функцию groupById(arr), которая создаст из него объект с id в
        качестве ключа и элементами массива в качестве значений.
      </p>
      <p>Например:</p>
      <pre class="code">
        let users = [
        {id: 'john', name: "John Smith", age: 20},
        {id: 'ann', name: "Ann Smith", age: 24},
        {id: 'pete', name: "Pete Peterson", age: 31},
      ];
      
      let usersById = groupById(users);
      
      /*
      после вызова у нас должно получиться:
      
      usersById = {
        john: {id: 'john', name: "John Smith", age: 20},
        ann: {id: 'ann', name: "Ann Smith", age: 24},
        pete: {id: 'pete', name: "Pete Peterson", age: 31},
      }
      */</pre
      >
      <p>
        Такая функция очень удобна при работе с данными, которые приходят с
        сервера.
      </p>
      <p>
        В этой задаче мы предполагаем, что id уникален. Не может быть двух
        элементов массива с одинаковым id.
      </p>
      <p>Используйте метод .reduce в решении.</p>
    </section>
  </body>
  <script src="script.js"></script>
</html>
